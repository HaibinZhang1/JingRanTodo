import React, { useState, useEffect } from 'react'
import { useAppDispatch } from '../hooks/useRedux'
import { useSelector } from 'react-redux'
import { createTask, updateTask, createSubtask, deleteSubtask, updateSubtask as updateSubtaskAction } from '../store/tasksSlice'
import { useSubtaskOperations } from '../hooks/useSubtaskOperations'
import { GlassPanel } from '../components'
import type { Task } from '../store/tasksSlice'
import type { RootState } from '../store'
import { parseIsoTime, combineDateAndTime, getToday } from '../utils/dateUtils'

import { TaskDetailHeader } from './task-detail/TaskDetailHeader'
import { TaskDetailContent } from './task-detail/TaskDetailContent'

interface TaskDetailModalProps {
    task?: Task | null
    isOpen: boolean
    onClose: () => void
    isDark?: boolean
}

/**
 * 任务详情编辑弹窗
 * - Refactored to use sub-components
 */
export const TaskDetailModal: React.FC<TaskDetailModalProps> = ({
    task,
    isOpen,
    onClose,
    isDark = false
}) => {
    const dispatch = useAppDispatch()
    // Get live task from Redux store for real-time subtask updates
    const liveTask = useSelector((state: RootState) =>
        task?.id ? state.tasks.items.find((t: Task) => t.id === task.id) : null
    )
    // Use live task if available, otherwise fall back to prop
    const currentTask = liveTask || task
    // 只有当 task 有 id 时才是编辑模式
    const isEditing = !!(currentTask?.id)

    // 表单状态
    const [title, setTitle] = useState(task?.title || '')
    const [description, setDescription] = useState(task?.description || '')
    const [priority, setPriority] = useState<'very-low' | 'low' | 'medium' | 'high' | 'very-high'>(task?.priority || 'low')

    // Parse Date helper (Local Time)
    const parseDate = (isoStr: string | null | undefined) => {
        if (!isoStr) return getToday()
        // If it looks like a full ISO string (UTC), parse it to local date
        if (isoStr.includes('T')) {
            const d = new Date(isoStr)
            if (!isNaN(d.getTime())) {
                const year = d.getFullYear()
                const month = String(d.getMonth() + 1).padStart(2, '0')
                const day = String(d.getDate()).padStart(2, '0')
                return `${year}-${month}-${day}`
            }
        }
        // Fallback for YYYY-MM-DD or simple strings
        return isoStr.split('T')[0]
    }

    const [startDate, setStartDate] = useState(parseDate(task?.start_date || task?.due_date))
    const [startHour, setStartHour] = useState<number>(() => {
        if (task?.start_date?.includes('T')) return parseIsoTime(task.start_date).hour
        return new Date().getHours()
    })
    const [startMinute, setStartMinute] = useState<number>(() => {
        if (task?.start_date?.includes('T')) return parseIsoTime(task.start_date).minute
        return new Date().getMinutes()
    })

    const [dueDate, setDueDate] = useState(parseDate(task?.due_date))
    const [endHour, setEndHour] = useState<number>(() => {
        if (task?.due_date?.includes('T')) return parseIsoTime(task.due_date).hour
        return 18
    })
    const [endMinute, setEndMinute] = useState<number>(() => {
        if (task?.due_date?.includes('T')) return parseIsoTime(task.due_date).minute
        return 0
    })

    // 新版提醒字段
    const getDefaultReminderTime = () => {
        const d = new Date()
        d.setMinutes(d.getMinutes() + 30)
        return d
    }
    const [reminderEnabled, setReminderEnabled] = useState(task?.reminder_enabled || false)
    const [reminderDate, setReminderDate] = useState(task?.reminder_date || getToday())
    const [reminderHour, setReminderHour] = useState<number>(task?.reminder_hour ?? getDefaultReminderTime().getHours())
    const [reminderMinute, setReminderMinute] = useState<number>(task?.reminder_minute ?? getDefaultReminderTime().getMinutes())

    // Daily generation for continuous tasks
    const [autoGenerateDaily, setAutoGenerateDaily] = useState(task?.auto_generate_daily ?? false)

    // Use custom hook for subtask operations
    const {
        localSubtasks,
        pendingNewSubtasks,
        pendingDeleteSubtaskIds,
        pendingSubtaskUpdates,
        displayedSubtasks,
        addSubtask,
        updateSubtask,
        deleteSubtask: deleteSubtaskOp,
        reset: resetSubtasks
    } = useSubtaskOperations({ task: currentTask, isEditing })

    // 当 task 改变时更新表单
    useEffect(() => {
        if (task?.id) {
            setTitle(task.title)
            setDescription(task.description || '')
            setPriority(task.priority)
            setStartDate(parseDate(task.start_date || task.due_date))
            const startTime = parseIsoTime(task.start_date)
            setStartHour(startTime.hour)
            setStartMinute(startTime.minute)
            setDueDate(parseDate(task.due_date))
            const endTime = parseIsoTime(task.due_date)
            setEndHour(task.due_date?.includes('T') ? endTime.hour : 18)
            setEndMinute(endTime.minute)
            setReminderEnabled(task.reminder_enabled || false)
            setReminderDate(task.reminder_date || parseDate(task.due_date))
            setReminderHour(task.reminder_hour ?? 9)
            setReminderMinute(task.reminder_minute ?? 0)
            setAutoGenerateDaily(!!task.auto_generate_daily)
        } else if (task?.title || task?.due_date) {
            setTitle(task.title || '')
            setDescription('')
            setPriority('low')
            setStartDate(parseDate(task.start_date || task.due_date))
            const startTime = parseIsoTime(task.start_date)
            setStartHour(startTime.hour)
            setStartMinute(startTime.minute)
            setDueDate(parseDate(task.due_date))
            const endTime = parseIsoTime(task.due_date)
            setEndHour(task.due_date?.includes('T') ? endTime.hour : 18)
            setEndMinute(endTime.minute)
            setReminderEnabled(false)
            setReminderDate(parseDate(task.due_date))
            setReminderHour(getDefaultReminderTime().getHours())
            setReminderMinute(getDefaultReminderTime().getMinutes())
            setAutoGenerateDaily(false)
            resetSubtasks()
        } else {
            setTitle('')
            setDescription('')
            setPriority('low')
            setStartDate(getToday())
            setStartHour(new Date().getHours())
            setStartMinute(new Date().getMinutes())
            setDueDate(getToday())
            setEndHour(18)
            setEndMinute(0)
            setReminderEnabled(false)
            setReminderDate(getToday())
            setReminderHour(getDefaultReminderTime().getHours())
            setReminderMinute(getDefaultReminderTime().getMinutes())
            setAutoGenerateDaily(false)
            resetSubtasks()
        }
    }, [task])

    // Keyboard shortcuts: ESC to cancel, Enter to save (only when not focused on textarea)
    useEffect(() => {
        if (!isOpen) return

        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                handleClose()
            }
            // Ctrl/Cmd + Enter to save
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                handleSave()
            }
        }

        window.addEventListener('keydown', handleKeyDown)
        return () => window.removeEventListener('keydown', handleKeyDown)
    }, [isOpen, title])

    const handleClose = () => {
        // Clear local state when closing
        resetSubtasks()
        onClose()
    }

    if (!isOpen) return null

    // 判断任务是否逾期 (仅编辑模式)
    const isOverdue = isEditing && currentTask?.status !== 'done' && !!currentTask?.due_date && (() => {
        const today = new Date()
        today.setHours(0, 0, 0, 0)
        const dueDateObj = new Date(currentTask.due_date)
        dueDateObj.setHours(0, 0, 0, 0)
        return today > dueDateObj
    })()

    const handleSave = async () => {
        if (!title.trim()) return

        // 检查提醒设置是否被修改
        const reminderChanged = isEditing && currentTask && (
            (currentTask.reminder_enabled !== reminderEnabled) ||
            (currentTask.reminder_date !== reminderDate) ||
            (currentTask.reminder_hour !== reminderHour) ||
            (currentTask.reminder_minute !== reminderMinute)
        )

        const taskData = {
            title: title.trim(),
            description: description.trim(),
            priority,
            start_date: combineDateAndTime(startDate, startHour, startMinute),
            due_date: combineDateAndTime(dueDate, endHour, endMinute),
            reminder_enabled: reminderEnabled,
            reminder_date: reminderEnabled ? reminderDate : undefined,
            reminder_hour: reminderEnabled ? reminderHour : undefined,
            reminder_minute: reminderEnabled ? reminderMinute : undefined,
            reminder_sent: reminderChanged ? false : (currentTask?.reminder_sent ?? false),
            auto_generate_daily: autoGenerateDaily,
            panel_id: task?.panel_id ?? null,
            status: task?.status || 'todo' as const
        }

        try {
            if (isEditing && currentTask) {
                // 1. Submit pending subtask operations FIRST
                // This ensures that when the parent task is updated (potentially triggering auto-generation),
                // the subtasks are already in the database and can be copied correctly.

                // Submit pending subtask deletions
                if (pendingDeleteSubtaskIds.length > 0) {
                    for (const subtaskId of pendingDeleteSubtaskIds) {
                        await dispatch(deleteSubtask({ taskId: currentTask.id, subtaskId })).unwrap()
                    }
                }

                // Submit pending subtask updates
                const updateEntries = Object.entries(pendingSubtaskUpdates)
                if (updateEntries.length > 0) {
                    for (const [subtaskId, updates] of updateEntries) {
                        const existingSubtask = currentTask.subtasks?.find(st => st.id === subtaskId)
                        if (existingSubtask) {
                            await dispatch(updateSubtaskAction({
                                ...existingSubtask,
                                ...updates,
                                // Ensure all date/time fields are explicitly passed if they were changed
                                start_date: updates.start_date ?? existingSubtask.start_date,
                                start_hour: updates.start_hour ?? existingSubtask.start_hour,
                                start_minute: updates.start_minute ?? existingSubtask.start_minute,
                                due_date: updates.due_date ?? existingSubtask.due_date,
                                due_hour: updates.due_hour ?? existingSubtask.due_hour,
                                due_minute: updates.due_minute ?? existingSubtask.due_minute,
                                reminder_date: updates.reminder_date ?? existingSubtask.reminder_date,
                                reminder_hour: updates.reminder_hour ?? existingSubtask.reminder_hour,
                                reminder_minute: updates.reminder_minute ?? existingSubtask.reminder_minute
                            })).unwrap()
                        }
                    }
                }

                // Submit pending subtask additions
                if (pendingNewSubtasks.length > 0) {
                    for (const st of pendingNewSubtasks) {
                        await dispatch(createSubtask({
                            taskId: currentTask.id,
                            title: st.title,
                            description: st.description,
                            priority: st.priority,
                            start_date: st.start_date,
                            start_hour: st.start_hour,
                            start_minute: st.start_minute,
                            due_date: st.due_date,
                            due_hour: st.due_hour,
                            due_minute: st.due_minute,
                            reminder_enabled: st.reminder_enabled,
                            reminder_date: st.reminder_date,
                            reminder_hour: st.reminder_hour,
                            reminder_minute: st.reminder_minute
                        })).unwrap()
                    }
                }

                // 2. Update main task
                // Now if auto_generate_daily is enabled/toggled, the subtasks exist.
                await dispatch(updateTask({ ...currentTask, ...taskData })).unwrap()

            } else {
                // Create new task
                // 1. Create task with auto_generate_daily = FALSE initially
                // This prevents immediate generation before subtasks are added.
                const initialAutoGenerate = taskData.auto_generate_daily
                const resultAction = await dispatch(createTask({
                    ...taskData,
                    auto_generate_daily: false, // Defer generation
                    created_at: task?.created_at
                }))

                if (createTask.fulfilled.match(resultAction)) {
                    const newTaskId = resultAction.payload.id

                    // 2. Create local subtasks for the new task
                    if (localSubtasks.length > 0) {
                        for (const st of localSubtasks) {
                            await dispatch(createSubtask({
                                taskId: newTaskId,
                                title: st.title,
                                description: st.description,
                                priority: st.priority,
                                start_date: st.start_date,
                                start_hour: st.start_hour,
                                start_minute: st.start_minute,
                                due_date: st.due_date,
                                due_hour: st.due_hour,
                                due_minute: st.due_minute,
                                reminder_enabled: st.reminder_enabled,
                                reminder_date: st.reminder_date,
                                reminder_hour: st.reminder_hour,
                                reminder_minute: st.reminder_minute
                            })).unwrap()
                        }
                    }

                    // 3. If auto-generate was requested, update the task to enable it
                    // This triggers the generation NOW, with subtasks in place.
                    if (initialAutoGenerate) {
                        await dispatch(updateTask({
                            ...resultAction.payload,
                            auto_generate_daily: true
                        })).unwrap()
                    }
                }
            }

            resetSubtasks()
            onClose()
        } catch (error) {
            console.error('Failed to save task:', error)
        }
    }

    return (
        <div
            className="fixed inset-0 z-[100] flex items-center justify-center bg-black/30 backdrop-blur-sm p-2 animate-fade-in"
            style={{ userSelect: 'auto', pointerEvents: 'auto', WebkitUserSelect: 'auto' } as any}
        >
            <GlassPanel
                isDark={isDark}
                variant="modal"
                className="w-full max-w-md max-h-[90vh] overflow-hidden flex flex-col relative shadow-2xl"
            >
                <TaskDetailHeader
                    isEditing={isEditing}
                    isOverdue={isOverdue}
                    onClose={handleClose}
                />

                <TaskDetailContent
                    title={title}
                    setTitle={setTitle}
                    description={description}
                    setDescription={setDescription}
                    priority={priority}
                    setPriority={setPriority}

                    startDate={startDate}
                    setStartDate={setStartDate}
                    startHour={startHour}
                    setStartHour={setStartHour}
                    startMinute={startMinute}
                    setStartMinute={setStartMinute}

                    dueDate={dueDate}
                    setDueDate={setDueDate}
                    endHour={endHour}
                    setEndHour={setEndHour}
                    endMinute={endMinute}
                    setEndMinute={setEndMinute}

                    reminderEnabled={reminderEnabled}
                    setReminderEnabled={setReminderEnabled}
                    reminderDate={reminderDate}
                    setReminderDate={setReminderDate}
                    reminderHour={reminderHour}
                    setReminderHour={setReminderHour}
                    reminderMinute={reminderMinute}
                    setReminderMinute={setReminderMinute}

                    autoGenerateDaily={autoGenerateDaily}
                    setAutoGenerateDaily={setAutoGenerateDaily}

                    subtasks={displayedSubtasks}
                    pendingSubtaskUpdates={pendingSubtaskUpdates}
                    onUpdateSubtask={updateSubtask}
                    onDeleteSubtask={(id, index) => deleteSubtaskOp(index, id)}
                    onAddSubtask={addSubtask}
                />

                <div className="p-1 border-t border-white/20 dark:border-gray-700/50 flex justify-end gap-3 shrink-0">
                    <button
                        onClick={handleClose}
                        className="px-4 py-2 text-gray-600 dark:text-gray-300 hover:bg-white/50 dark:hover:bg-gray-700/50 rounded-xl transition-colors"
                    >
                        取消
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={!title.trim()}
                        className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-xl shadow-lg shadow-blue-500/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed transform active:scale-95"
                    >
                        {isEditing ? '保存' : '添加'}
                    </button>
                </div>
            </GlassPanel>
        </div>
    )
}

export default TaskDetailModal
