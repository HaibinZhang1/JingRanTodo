# Desktop Embed Position Fix - Walkthrough

## Problem Description
浮动窗口切换到桌面嵌入模式时，窗口会闪烁并跳到错误的位置。问题在 225% DPI 缩放 + 1440x2560 纵向显示器 + 双屏配置下尤为明显。

## Root Cause Analysis

### 1. 坐标系统不一致
- **Electron 坐标**: 使用 DPI 缩放后的逻辑像素 (如 `2288, 608`)
- **Win32 坐标**: 使用物理屏幕像素 (如 `2860, 760`)
- 两者之间存在固定偏移，不是简单的 DPI 缩放关系

### 2. SetParent 改变坐标系统
调用 `SetParent(hwnd, container)` 后，即使保持 `WS_POPUP` 样式，窗口的坐标参考系也会从**屏幕坐标**变为**父窗口客户区坐标**。

### 3. SetWindowPos 坐标解释错误
对于有父窗口的 `WS_POPUP` 窗口，`SetWindowPos` 的 X/Y 参数是**相对于父窗口客户区**的，而不是屏幕坐标：

```
容器位于: screen(0, -555)  // 负Y是因为纵向显示器布局
Window at: screen(2860, 760)

错误做法: SetWindowPos(hwnd, ..., 2860, 760, ...)
结果位置: screen(2860, 205)  // 760 - 555 = 205 ❌

正确做法: SetWindowPos(hwnd, ..., 2860, 1315, ...)  // 760 - (-555) = 1315
结果位置: screen(2860, 760) ✓
```

## Solution

### 核心修复 in [desktopAttach.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/main/desktopAttach.ts)

在 [attachToDesktopAboveIcons](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/ref_desktopAttach.ts#346-417) 函数中：

```typescript
// 1. 保存窗口当前屏幕位置
const rect = { left: 0, top: 0, right: 0, bottom: 0 }
GetWindowRect(hwnd, rect)
const screenX = rect.left  // 2860
const screenY = rect.top   // 760

// 2. 设置父窗口
SetParent(hwnd, container)

// 3. 获取容器的屏幕位置
const containerRect = { left: 0, top: 0, right: 0, bottom: 0 }
GetWindowRect(container, containerRect)  // (0, -555)

// 4. 转换屏幕坐标到客户区坐标
const targetClientX = screenX - containerRect.left  // 2860 - 0 = 2860
const targetClientY = screenY - containerRect.top   // 760 - (-555) = 1315

// 5. 使用客户区坐标设置位置
SetWindowPos(hwnd, HWND_TOP, targetClientX, targetClientY, width, height,
    SWP_SHOWWINDOW | SWP_NOACTIVATE)
```

### 窗口重建方案 in [cardWindow.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/main/cardWindow.ts)

切换模式时采用**窗口重建**而非直接修改现有窗口：

1. 保存当前窗口的 Electron bounds（如果从 floating 模式切换，使用 `getBounds()`；如果从 desktop 模式切换，使用设置中保存的位置）
2. 销毁旧窗口
3. 在保存的位置创建新窗口
4. 如果是 desktop 模式，调用 [toggleDesktopMode](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/ref_desktopAttach.ts#485-499) 附加到桌面

这样可以避免 Electron 的 `setBounds()` 在 SetParent 后失效的问题。

## Key Learnings

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| `setBounds()` 无效 | SetParent 后 Electron 坐标系统与 Win32 不匹配 | 使用 Win32 原生 `SetWindowPos` |
| 位置偏移 555 像素 | 容器在 screen(0, -555) | 计算客户区坐标：`clientY = screenY - containerTop` |
| `getBounds()` 返回错误值 | Desktop 模式下坐标已被破坏 | 使用设置中保存的浮动模式位置 |

## Files Modified

- [src/main/desktopAttach.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/main/desktopAttach.ts) - 添加屏幕到客户区坐标转换
- [src/main/cardWindow.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/main/cardWindow.ts) - 实现窗口重建方案，正确处理两种模式的坐标保存

---

# 浮窗贴边收起展开逻辑修复 (2024-12-24)

## Problem Description

任务卡片浮窗贴边收起展开功能存在两个问题：

1. **展开触发区域过大**：浮窗收起后，鼠标移到原浮窗区域（而非5px小横条）就会展开
2. **标题栏区域会立即收起**：鼠标在标题栏/菜单栏区域移动时，浮窗会意外收起

## Root Cause Analysis

### 1. 事件监听器位置错误
`onMouseEnter`/`onMouseLeave` 事件监听器放在占据整个屏幕大小的最外层 div (`h-screen w-screen`) 上，而不是实际可见的内容区域。

### 2. WebkitAppRegion: drag 导致事件丢失
标题栏使用 `style={{ WebkitAppRegion: 'drag' }}` 启用窗口拖拽，但这会导致该区域内的鼠标事件不正常冒泡，Electron 会认为鼠标离开了普通网页区域。

## Solution

### 修复1：调整事件监听器位置

**文件**: [DesktopWidget.tsx](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/renderer/components/DesktopWidget.tsx#L531-L541)

将事件监听器从最外层 div 移到内层可移动容器上：

```tsx
// 外层不再监听鼠标事件
<div className="h-screen w-screen bg-transparent overflow-hidden relative">
    // 内层容器监听鼠标事件（这个容器会随 transform 移动）
    <div
        className="h-full w-full transition-transform duration-300 ease-out"
        style={{ transform: getEdgeTransform() }}
        onMouseEnter={handleEdgeMouseEnter}
        onMouseLeave={handleEdgeMouseLeave}
    >
```

### 修复2：添加系统级鼠标位置检查

**文件**: [DesktopWidget.tsx](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/renderer/components/DesktopWidget.tsx) (handleEdgeMouseLeave 函数)

在收起定时器触发前，通过 IPC 获取系统级鼠标位置，确认鼠标确实在窗口外：

```tsx
const checkMousePosition = () => {
    const windowX = window.screenX
    const windowY = window.screenY
    const windowW = window.innerWidth
    const windowH = window.innerHeight
    
    if ((window as any).electronAPI?.getMousePosition) {
        return (window as any).electronAPI.getMousePosition().then((pos: { x: number, y: number }) => {
            const isInside = pos.x >= windowX && pos.x <= windowX + windowW &&
                           pos.y >= windowY && pos.y <= windowY + windowH
            return !isInside  // 返回 true 表示应该收起
        })
    }
    return Promise.resolve(true)
}

checkMousePosition().then((shouldCollapse: boolean) => {
    if (shouldCollapse && !mouseInAreaRef.current && !isDraggingRef.current && isDocked) {
        setIsExpanded(false)
    }
})
```

### 修复3：新增 IPC API

**文件**: [cardWindow.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/main/cardWindow.ts#L6-L10)

```typescript
// 主进程 - 获取系统级鼠标位置
ipcMain.handle('get-mouse-position', () => {
    const point = screen.getCursorScreenPoint()
    return { x: point.x, y: point.y }
})
```

**文件**: [preload/index.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/preload/index.ts#L94-L96)

```typescript
// Preload 暴露 API
getMousePosition: () => ipcRenderer.invoke('get-mouse-position'),
```

## Key Learnings

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 收起后整个窗口区域都能触发展开 | 事件监听器在 `h-screen w-screen` 的外层容器 | 将事件监听器移到内层 transform 容器 |
| 标题栏区域触发意外收起 | `WebkitAppRegion: drag` 导致 mouseLeave 误触发 | 收起前用 `screen.getCursorScreenPoint()` 确认鼠标位置 |
| 无法在渲染进程获取准确鼠标位置 | DOM 事件的坐标可能不准确 | 通过 IPC 调用 Electron 主进程的 `screen` API |

## Files Modified

- [src/renderer/components/DesktopWidget.tsx](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/renderer/components/DesktopWidget.tsx) - 调整事件监听器位置，添加鼠标位置检查
- [src/main/cardWindow.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/main/cardWindow.ts) - 添加 `get-mouse-position` IPC 处理器
- [src/preload/index.ts](file:///f:/new_work/ZenHubBoard_105/ZenHubBoard/src/preload/index.ts) - 暴露 `getMousePosition` API
